#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Google Play Music Proxy
# Â© Mario Di Raimondo < mario.diraimondo (at) gmail.com >
# "Let's stream Google Play Music using any media-player"
#
# contributors:
#  - Gianluca Boiano
#  - Nick Depinet < depinetnick (at) gmail.com >
#  - Adam Prato < adam.prato (at) gmail.com >
#  - Pierre Karashchuk < krchtchk (at) gmail.com >
#  - Alex Busenius
#  - Mark Gillespie < mark.gillespie (at) gmail.com >
#
# license: GPL v3
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import argparse
import errno
import logging
import os
import pprint
import random
import signal
import socket
import sys
import tempfile
import threading
from configparser import ConfigParser
from http.server import BaseHTTPRequestHandler, HTTPServer
from socketserver import ThreadingMixIn
from urllib.parse import parse_qs, urlparse
from urllib.request import build_opener

import eyed3.id3
import gmusicapi
import gmusicapi.utils
import requests
from gmusicapi.exceptions import CallFailure
from jinja2 import Template
import json
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


try:
    import daemon
except Exception:
    pass


class MultiThreadedHTTPServer(ThreadingMixIn, HTTPServer):
    daemon_threads = True


class GetHandler(BaseHTTPRequestHandler):

    def do_GET(self):
        logger.debug("request path: %s", self.path)
        parsedPath = urlparse(self.path)
        params = parse_qs(parsedPath.query)

        if parsedPath.path == "/get_song" and "id" in params:
            if 'quality' in params:
                self._get_song(id=params['id'][0], quality=params['quality'][0])
            else:
                self._get_song(id=params['id'][0])        
        elif parsedPath.path == "/get_all_stations":
            self._send_headers(
                200,
                "audio/mpegurl",
                "inline; filename=playlist.%s" % "txt" if
                ("format" in params
                 and params["format"][0].lower().strip() == "text") else "m3u",
            )

            if self._check_aa():
                return
            self._get_all_stations(
                format=params["format"][0] if "format" in params else "m3u",
                separator=params["separator"][0]

                if "separator" in params else "|",
                onlyUrl=params["only_url"][0]

                if "only_url" in params else "no",
            )

        elif parsedPath.path == "/get_all_playlists":
            self._send_headers(
                200,
                "audio/mpegurl",
                "inline; filename=playlist.%s" % "txt" if
                ("format" in params
                 and params["format"][0].lower().strip() == "text") else "m3u",
            )
            self._get_all_playlists(
                format=params["format"][0] if "format" in params else "m3u",
                separator=params["separator"][0]

                if "separator" in params else "|",
                onlyUrl=params["only_url"][0]

                if "only_url" in params else "no",
            )

        elif parsedPath.path == "/get_station" and "id" in params:
            self._send_headers(200, "audio/mpegurl",
                               "inline; filename=playlist.m3u")

            if self._check_aa():
                return
            self._get_station(
                id=params["id"][0],
                numTracks=params["num_tracks"][0]

                if "num_tracks" in params else defaultNumberTracksStation,
            )

        elif parsedPath.path == "/get_ifl_station":
            self._send_headers(200, "audio/mpegurl",
                               "inline; filename=playlist.m3u")

            if self._check_aa():
                return
            self._get_station(
                id="IFL",
                numTracks=params["num_tracks"][0]

                if "num_tracks" in params else defaultNumberTracksStation,
            )

        elif parsedPath.path == "/get_playlist" and "id" in params:
            self._send_headers(200, "audio/mpegurl",
                               "inline; filename=playlist.m3u")
            self._get_playlist(
                id=params["id"][0],
                shuffle=True if ("shuffle" in params
                                 and params["shuffle"][0] == "yes") else False,
            )

        elif parsedPath.path == "/get_album" and "id" in params:
            self._send_headers(200, "audio/mpegurl",
                               "inline; filename=playlist.m3u")

            if self._check_aa():
                return
            self._get_album(id=params["id"][0])

        elif parsedPath.path == "/get_top_tracks_artist" and "id" in params:
            self._send_headers(200, "audio/mpegurl",
                               "inline; filename=playlist.m3u")

            if self._check_aa():
                return
            self._get_top_tracks_artist(
                id=params["id"][0],
                numTracks=params["num_tracks"][0]

                if "num_tracks" in params else defaultNumberTopTracks,
            )

        elif parsedPath.path == "/get_discography_artist" and "id" in params:
            self._send_headers(
                200,
                "audio/mpegurl",
                "inline; filename=playlist.%s" % "txt" if
                ("format" in params
                 and params["format"][0].lower().strip() == "text") else "m3u",
            )

            if self._check_aa():
                return
            self._get_discography_artist(
                id=params["id"][0],
                format=params["format"][0] if "format" in params else "m3u",
                separator=params["separator"][0]

                if "separator" in params else "|",
                onlyUrl=params["only_url"][0]

                if "only_url" in params else "no",
            )

        elif parsedPath.path == "/get_collection":
            self._send_headers(200, "audio/mpegurl",
                               "inline; filename=playlist.m3u")
            self._get_collection(
                ratingthreshold=params["rating"][0]

                if "rating" in params else 0,
                shuffle=True if ("shuffle" in params 
                                and params["shuffle"][0] == "yes") else False,
            )

        ##  FUNCTIONS FOR JSON API ##
        elif parsedPath.path == "/browser":
            self._send_headers(200, 'text/html')
            self._browser()
        elif parsedPath.path == "/get_stations_json":
            self._send_headers(200, 'application/json')
            self._get_stations_json()
        elif parsedPath.path == "/get_station_json" and "name" in params:
            self._send_headers(200, 'application/json')
            self._get_station_json(name=params["name"][0],numTracks=params["numtracks"][0] if "numtracks" in params else "999")
        elif parsedPath.path == "/get_playlists_json":
            self._send_headers(200, 'application/json')
            self._get_playlists_json()
        elif parsedPath.path == "/get_playlist_json" and "name" in params:
            self._send_headers(200, 'application/json')
            self._get_playlist_json(name=params["name"][0])
        elif parsedPath.path == "/get_collection_artists_json":
            self._send_headers(200, 'application/json')
            self._get_collection_artists_json()
        elif parsedPath.path == "/get_collection_json":
            self._send_headers(200, 'application/json')
            self._get_collection_json()
        elif parsedPath.path == "/get_collection_albums_json":
            self._send_headers(200, 'application/json')
            self._get_collection_albums_json(params["artist"][0] if "artist" in params else "All Artists")
        elif parsedPath.path == "/get_tracks_json":
            self._send_headers(200, 'application/json')
            self._get_tracks_json(params["artist"][0] if "artist" in params else "All Artists",params["album"][0] if "album" in params else "All Albums")
        elif parsedPath.path == "/get_track_json" and "id" in params:
            logger.info("/get_track_json")
            self._send_headers(200, 'application/json')
            self._get_track_json(track_id=params["id"][0])

        ## FUNCTIONS FOR QUEUE HANDLNG ##
        
        elif parsedPath.path == "/shuffle_queue":
            self._send_headers(200, 'text/html')
            self._shuffle_queue()
        elif parsedPath.path == "/clear_queue":
            self._send_headers(200, 'text/html')
            self._clear_queue()
        elif parsedPath.path == "/append_to_queue":
            self._send_headers(200, 'text/html')
            artist  = ""
            album   = ""
            station = ""
            playlist = ""
            if "station" in params:
                station = params["station"][0]
            if "playlist" in params:
                playlist = params["playlist"][0]
            if "album" in params:
                artist = params["artist"][0] if "artist" in params else "All Artists"
                album  = params["album"][0] if "album" in params else "All Albums"        
            self._append_to_queue(station=station,artist=artist,album=album,playlist=playlist)
        elif parsedPath.path == "/get_queue_json":
            self._send_headers(200, 'application/json')
            self._get_queue_json()
        elif parsedPath.path == "/next_track":
            self._send_headers(200, 'application/json')
            self._next_track()
        elif parsedPath.path == "/prev_track":
            self._send_headers(200, 'application/json')
            self._previous_track()
        elif parsedPath.path == "/current_track":
            self._send_headers(200, 'application/json')
            self._current_track()
        elif parsedPath.path == "/update_cache":
            self._send_headers(200, 'application/json')
            self._fetch_songs_list_cache()
            self._fetch_playlist_cache()
            self.wfile.write(json.dumps({'result':'ok'}).encode("utf-8"))
        #####            
        elif parsedPath.path == "/get_listen_now":
            self._send_headers(
                200,
                "audio/mpegurl",
                "inline; filename=playlist.%s" % "txt" if
                ("format" in params
                 and params["format"][0].lower().strip() == "text") else "m3u",
            )

            if self._check_aa():
                return

            self._get_listen_now(
                format=params["format"][0] if "format" in params else "m3u",
                type=params["type"][0] if "type" in params else "album",

                separator=params["separator"][0]
                if "separator" in params else "|",
                onlyUrl=params["only_url"][0]

                if "only_url" in params else "no",
            )

        elif parsedPath.path == "/get_situations":
            self._send_headers(
                200,
                "audio/mpegurl",
                "inline; filename=playlist.%s" % "txt" if
                ("format" in params
                 and params["format"][0].lower().strip() == "text") else "m3u",
            )

            if self._check_aa():
                return
            self._get_situations(
                format=params["format"][0] if "format" in params else "m3u",
                separator=params["separator"][0]

                if "separator" in params else "|",
                onlyUrl=params["only_url"][0]

                if "only_url" in params else "no",
            )

        elif parsedPath.path == "/get_promoted":
            self._send_headers(200, "audio/mpegurl",
                               "inline; filename=playlist.m3u")
            self._get_promoted(
                shuffle=True if ("shuffle" in params
                                 and params["shuffle"][0] == "yes") else False,
            )

        elif (parsedPath.path == "/search_id" and "type" in params
              and ("title" in params or "artist" in params)):
            self._send_headers(200)

            if self._check_aa():
                return
            result = self._search(
                type=params["type"][0].lower().strip()

                if "type" in params else "artist",
                query_title=params["title"][0]

                if "title" in params else "",
                query_artist=params["artist"][0]

                if "artist" in params else "",
                exact=params["exact"][0].lower().strip()

                if "exact" in params else "yes",
            )

            if result:
                self.wfile.write(result.encode('utf-8'))

        elif (parsedPath.path == "/get_by_search" and "type" in params
              and ("title" in params or "artist" in params)):

            if self._check_aa():
                return

            if "type" in params and params["type"][0].lower().strip(
            ) != "song":
                self._send_headers(200, "audio/mpegurl",
                                   "inline; filename=playlist.m3u")
            result = self._search(
                type=params["type"][0].lower().strip()

                if "type" in params else "artist",
                query_title=params["title"][0]

                if "title" in params else "",
                query_artist=params["artist"][0]

                if "artist" in params else "",
                exact=params["exact"][0].lower().strip()

                if "exact" in params else "no",
                max_results=params["num_tracks"][0]

                if "num_tracks" in params else None,
            )

            if result and len(result) > 0:
                if params["type"][0].lower().strip() == "artist":
                    self._get_top_tracks_artist(
                        result,
                        numTracks=params["num_tracks"][0]

                        if "num_tracks" in params else defaultNumberTopTracks,
                    )
                elif params["type"][0].lower().strip() == "song":
                    self._get_song(result)
                elif params["type"][0].lower().strip() == "album":
                    self._get_album(result)
                elif params["type"][0].lower().strip() == "matches":
                    self._get_matches(
                        result,
                        numTracks=params["num_tracks"][0]

                        if "num_tracks" in params else defaultNumberTopTracks,
                    )

        elif (parsedPath.path == "/get_new_station_by_id" and "id" in params
              and "type" in params):
            self._send_headers(200, "audio/mpegurl",
                               "inline; filename=playlist.m3u")

            if self._check_aa():
                return

            if ("transient" in params
                    and params["transient"][0].lower().strip() == "no"
                    and ("name" not in params or len(params["name"][0]) == 0)):
                logger.warning("A new persistent station requires a name!")

                return
            self._get_new_station(
                id=params["id"][0],
                type=params["type"][0].lower().strip(),
                numTracks=params["num_tracks"][0]

                if "num_tracks" in params else defaultNumberTracksStation,
                transient=params["transient"][0].lower().strip()

                if "transient" in params else "yes",
                name=params["name"][0]

                if "name" in params else transientStationName,
            )

        elif (parsedPath.path == "/get_new_station_by_search"
              and "type" in params
              and ("title" in params or "artist" in params)):
            self._send_headers(200, "audio/mpegurl",
                               "inline; filename=playlist.m3u")

            if self._check_aa():
                return

            if ("transient" in params
                    and params["transient"][0].lower().strip() == "no"
                    and ("name" not in params or len(params["name"][0]) == 0)):
                logger.warning("A new persistent station requires a name!")

                return
            result = self._search(
                type=params["type"][0].lower().strip()

                if "type" in params else "artist",
                query_title=params["title"][0]

                if "title" in params else "",
                query_artist=params["artist"][0]

                if "artist" in params else "",
                exact=params["exact"][0].lower().strip()

                if "exact" in params else "no",
            )

            if result and len(result) > 0:
                self._get_new_station(
                    id=result,
                    type=params["type"][0].lower().strip(),
                    numTracks=params["num_tracks"][0]

                    if "num_tracks" in params else defaultNumberTracksStation,
                    transient=params["transient"][0].lower().strip()

                    if "transient" in params else "yes",
                    name=params["name"][0]

                    if "name" in params else transientStationName,
                )

        elif parsedPath.path == "/like_song" and "id" in params:
            self._send_headers(200)
            self._rate_song(id=params["id"][0], rating=5)

        elif parsedPath.path == "/dislike_song" and "id" in params:
            self._send_headers(200)
            self._rate_song(id=params["id"][0], rating=1)

        else:
            self._send_headers(500)
            logger.warning(
                "Unknown command '%s' or missing required parameter!",
                parsedPath.path)

        return

    def do_HEAD(self):
        logger.debug("HEAD request path: %s", self.path)
        parsedPath = urlparse(self.path)
        params = parse_qs(parsedPath.query)

        if parsedPath.path == "/get_song" and "id" in params:
            self._get_song(id=params["id"][0], only_headers=True)
        else:
            self._send_headers(500)
            logger.warning(
                "Unknown command '%s' or missing required parameter!",
                parsedPath.path)

        return

    def _send_headers(
            self,
            response_code=200,
            content_type=None,
            content_disposition=None,
            content_length=None,
            icy_metaint=None,
            icy_name=None,
    ):
        self.send_response(response_code)

        if content_type:
            self.send_header("Content-Type", content_type)

        if content_disposition:
            self.send_header("Content-Disposition", content_disposition)

        if content_length:
            self.send_header("Content-Length", content_length)

        if icy_metaint:
            self.send_header("icy-metaint", icy_metaint)

        if icy_name:
            self.send_header("icy-name", icy_name)
        self.send_header("Access-Control-Allow-Origin", "*")
        self.end_headers()

    def _check_aa(self):
        if config["disable_all_access"]:
            logger.warning(
                "This functionality requires an All Access subscription!")

        return config["disable_all_access"]

    def _fetch_songs_list_cache(self):
        logger.debug("Fetching list of songs in collection")
        with self.server.lock:
           self.server.allSongsCache = self._robust_retry(lambda: api.get_all_songs())

    def _fetch_playlist_cache(self):
        logger.debug("Fetching list of playlists in collection")
        with self.server.lock:
            self.server.allPlaylistsCache = self._robust_retry(lambda: api.get_all_user_playlist_contents()) 

    def _icy_name(self, album=None, artist=None, title=None):
        return ("%s /// %s /// %s" % (artist, album, title)).encode("utf-8")

    def _icy_metadata(self, album=None, artist=None, title=None):
        text = "StreamTitle='%ss';" % (self._icy_name(album, artist,
                                                      title).decode("utf-8"))
        metadata = (chr(len(text)) + text).ljust(len(text) * 16 + 1, chr(0))

        return metadata.encode("utf-8")

    def _get_song(self, id, only_headers=False, quality='hi'):
        if config["disable_all_access"] or id[0] != "T":
            info = None
            # this more expensive method to get track info is necessary if we
            # can't use the All Access 'get_track_info' method or if we are
            # using the universal (uuid-style) id (tracks in collection)
            # I try to mitigate the fetch cost using a RAM-based cache

            if not hasattr(self.server, "allSongsCache"):
                self._fetch_songs_list_cache()
            refetchOnFailure = True

            while True:
                with self.server.lock:
                    for song in self.server.allSongsCache:
                        if (("storeId" in song and song["storeId"] == id)
                                or ("nid" in song and song["nid"] == id)
                                or ("id" in song and song["id"] == id)):
                            info = song.copy()
                            refetchOnFailure = False

                            break

                if info is None and refetchOnFailure:
                    logger.debug(
                        "Look-up failure in cache for track info, refetching!")
                    self._fetch_songs_list_cache()
                    refetchOnFailure = False
                else:
                    break
        else:
            if id[0] == "T":
                info = self._robust_retry(lambda: api.get_track_info(
                    store_track_id=id))
            else:
                logger.error(
                    "Unsupported id '%s': report info to reproduce this to the author",
                    id,
                )

        if info is None:
            logger.info("Streaming song with id '%s'", id)
            tagsBin = None
            tagsSize = 0
            songSize = 0
        else:
            logger.info(
                "Streaming song with id '%s': %s - %s",
                id,
                info["artist"],
                info["title"],
            )
            logger.debug(pprint.pformat(info))
            tags = eyed3.id3.Tag()

            if "artist" in info:
                tags.artist = info["artist"]
            # extra check for support of 'album_artist' by eyed3:
            # https://bitbucket.org/nicfit/eyed3/commits/9071bba4977f

            if "albumArtist" in info and "album_artist" in dir(tags):
                tags.album_artist = info["albumArtist"]

            if "album" in info:
                tags.album = info["album"]

            if "title" in info:
                tags.title = info["title"]

            if "trackNumber" in info:
                tags.track_num = info["trackNumber"]

            if "discNumber" in info:
                tags.disc_num = info["discNumber"]

            if "genre" in info:
                tags.genre = eyed3.id3.Genre(info["genre"])

            if "albumArtRef" in info:
                albumArt = opener.open(info["albumArtRef"][0]["url"]).read()
                tags.images.set(3, albumArt, "image/jpeg")

            if "year" in info and info["year"]:
                tags.recording_date = int(info["year"])

            if "estimatedSize" in info:
                songSize = int(info["estimatedSize"])
            else:
                songSize = 0
            # weird hack: write the id3 tag on a temporary file and reload it
            # (no way to render it on memory...)
            tempFile = tempfile.NamedTemporaryFile(delete=False)
            tags.save(tempFile.name)
            tagsBin = tempFile.read()
            tagsSize = len(tagsBin)
            tempFile.close()
            os.unlink(tempFile.name)

        url = self._robust_retry(lambda: api.get_stream_url(song_id=id, quality=quality))
        logger.debug("streaming url: %s", url)

        do_shoutcast = config[
            "shoutcast_metadata"] and "icy-metadata" in self.headers

        mp3 = opener.open(url)
        logger.debug("tag size: %s byte", tagsSize)
        logger.debug("content estimated size: %s byte", songSize)

        if mp3.info().get("Content-Length"):
            songSize = int(mp3.info().get("Content-Length"))
        logger.debug("content size from HTTP headers: %s byte", songSize)

        self._send_headers(
            200,
            "audio/mpeg",
            "inline; filename=%s.mp3" % id.strip(),
            ((tagsSize if not do_shoutcast else 0) + songSize) if
            (songSize > 0) else None,
            downloadBlockSize if do_shoutcast else None,
            self._icy_name(tags.album, tags.artist, tags.title)

            if config["shoutcast_metadata"] else None,
        )

        if not only_headers:
            if tagsBin and not do_shoutcast:
                self.wfile.write(tagsBin)

            # prefill cache
            writtenBytes = 0
            block = mp3.read(downloadBlockSize)

            while len(block) > 0:
                self.wfile.write(block)
                writtenBytes += len(block)

                if do_shoutcast:
                    self.wfile.write(
                        self._icy_metadata(tags.album, tags.artist,
                                           tags.title))
                block = mp3.read(downloadBlockSize)

                if (songSize > 0 and writtenBytes > cachePrefillSize
                        and songSize - writtenBytes < maxCacheSize):

                    break

            if not config["disable_playcount_increment"]:
                logger.info("Increment playcount")
                self._robust_retry(
                    lambda: api.increment_song_playcount(song_id=id))

            if songSize < 0:
                return

            # consume the end of stream
            cache = bytearray(0)

            while len(block) > 0:
                cache.extend(block)
                block = mp3.read(downloadBlockSize)

            # serve from cache
            cacheSize = len(cache)
            position = 0

            while position < cacheSize:
                self.wfile.write(
                    cache[position:position +
                          min(cacheSize - position, downloadBlockSize)])
                position += downloadBlockSize

                if do_shoutcast:
                    self.wfile.write(
                        self._icy_metadata(tags.album, tags.artist,
                                           tags.title))

    def _get_all_stations(self, format, separator, onlyUrl):
        logger.info("Getting all stations as plain-text list..." if format ==
                    "text" else "Getting all stations as M3U list...")
        stations = self._robust_retry(lambda: api.get_all_stations())
        logger.debug(pprint.pformat(stations))

        if format.lower().strip() != "text":
            self.wfile.write("#EXTM3U\n".encode("utf-8"))
        logger.debug("generated playlist:" if format.lower().strip() ==
                     "text" else "generated playlist:\n#EXTM3U")

        for station in stations:
            if "id" in station:
                if format.lower().strip() == "text":
                    line = "%s%s:%s/get_station?id=%s" % (
                        "%s%s" % (station["name"], separator) if
                        ("name" in station
                         and onlyUrl.lower().strip() != "yes") else "",
                        config["host"],
                        config["port"],
                        station["id"],
                    )
                else:
                    line = "#EXTINF:-1,%s\n%s:%s/get_station?id=%s" % (
                        station["name"] if "name" in station else "",
                        config["host"],
                        config["port"],
                        station["id"],
                    )
                self.wfile.write(("%s\n" % line).encode("utf-8"))
                logger.debug(line)

    def _get_situations(self, format, separator, onlyUrl):
        logger.info("Getting Listen Now situations as plain-text list..." if format ==
                    "text" else "Getting Listen Now situations as M3U list...")
        situations = self._robust_retry(lambda: api.get_listen_now_situations())
        logger.debug(pprint.pformat(situations))

        if format.lower().strip() != "text":
            self.wfile.write("#EXTM3U\n".encode("utf-8"))
        logger.debug("generated playlist:" if format.lower().strip() ==
                     "text" else "generated playlist:\n#EXTM3U")

        for situation in situations:
            if "id" in situation:
                name = situation["title"]
                curatedId = situation["stations"][0]["seed"]["curatedStationId"]
                stationId = api.create_station(
                    name=name,
                    curated_station_id=curatedId,
                )
                if format.lower().strip() == "text":
                    line = "%s%s:%s/get_station?id=%s" % (
                        "Listen Now - %s%s" % (name, separator) if
                        ("title" in situation
                         and onlyUrl.lower().strip() != "yes") else "Listen Now",
                        config["host"],
                        config["port"],
                        stationId,
                    )
                else:
                    line = "#EXTINF:-1,%s\n%s:%s/get_station?id=%s" % (
                        "Listen Now - %s" % name,
                        config["host"],
                        config["port"],
                        stationId,
                    )
                self.wfile.write(("%s\n" % line).encode("utf-8"))
                logger.debug(line)
            self._robust_retry(lambda: api.delete_stations(stationId))

    def _get_listen_now(self, format, type, separator, onlyUrl):
        logger.info("Getting Listen Now artists or albums as plain-text list..." if format ==
                    "text" else "Getting Listen Now artists or albums as M3U list...")
        items = self._robust_retry(lambda: api.get_listen_now_items())
        logger.debug(pprint.pformat(items))

        if format.lower().strip() != "text":
            self.wfile.write("#EXTM3U\n".encode("utf-8"))
        logger.debug("generated playlist:" if format.lower().strip() ==
                     "text" else "generated playlist:\n#EXTM3U")

        for item in items:
            if type == "artist":
                if "radio_station" in item:
                    artist = item["radio_station"]["title"]
                    seed = item["radio_station"]["id"]["seeds"][0]
                    if "artistId" in seed:
                        stationId = api.create_station(
                            name=artist,
                            artist_id=seed["artistId"],
                        )
                        if format.lower().strip() == "text":
                            line = "%s%s:%s/get_station?id=%s" % (
                                "Listen Now - %s%s" % (artist, separator) if
                                onlyUrl.lower().strip() != "yes" else "",
                                config["host"],
                                config["port"],
                                stationId,
                            )
                        else:
                            line = "#EXTINF:-1,%s\n%s:%s/get_station?id=%s" % (
                                "Listen Now - %s" % artist,
                                config["host"],
                                config["port"],
                                stationId,
                            )
                        self.wfile.write(("%s\n" % line).encode("utf-8"))
                        logger.debug(line)
            else:
                if "album" in item:
                    info = item["album"]["id"]
                    albumId = info["metajamCompactKey"]
                    artist = info["artist"]
                    title = info["title"]
                    if format.lower().strip() == "text":
                        line = "%s%s:%s/get_album?id=%s" % (
                            "Listen Now - %s's %s%s" % (artist, title, separator) if
                            onlyUrl.lower().strip() != "yes" else "",
                            config["host"],
                            config["port"],
                            albumId,
                        )
                    else:
                        line = "#EXTINF:-1,%s\n%s:%s/get_album?id=%s" % (
                            "Listen Now - %s's %s" % (artist, title),
                            config["host"],
                            config["port"],
                            albumId,
                        )
                    self.wfile.write(("%s\n" % line).encode("utf-8"))
                    logger.debug(line)

    def _get_all_playlists(self, format, separator, onlyUrl):
        logger.info(
            "Getting all playlists as plain-text list..." if format.lower(
            ).strip() == "text" else "Getting all playlists as M3U list...")
        playlists = self._robust_retry(lambda: api.get_all_playlists())
        logger.debug(pprint.pformat(playlists))

        if format.lower().strip() != "text":
            self.wfile.write("#EXTM3U\n")
        logger.debug("generated playlist:" if format.lower().strip() ==
                     "text" else "generated playlist:\n#EXTM3U")

        for playlist in playlists:
            if "id" in playlist:
                useToken = False

                if "type" in playlist and playlist["type"] == "SHARED":
                    useToken = True

                if format.lower().strip() == "text":
                    line = "%s%s:%s/get_playlist?id=%s" % (
                        "%s%s" % (playlist["name"], separator) if
                        ("name" in playlist
                         and onlyUrl.lower().strip() != "yes") else "",
                        config["host"],
                        config["port"],
                        playlist["id"]

                        if not useToken else playlist["shareToken"],
                    )
                else:
                    line = "#EXTINF:-1,%s\n%s:%s/get_playlist?id=%s" % (
                        playlist["name"] if "name" in playlist else "",
                        config["host"],
                        config["port"],
                        playlist["id"]

                        if not useToken else playlist["shareToken"],
                    )
                self.wfile.write(("%s\n" % line).encode("utf-8"))
                logger.debug(line)

    def _get_station(self, id, numTracks):
        station = self._robust_retry(lambda: api.get_station_tracks(
            station_id=id, num_tracks=numTracks))
        logger.info("Getting %s tracks from station with id '%s'", numTracks,
                    id)
        logger.debug(pprint.pformat(station))
        self.wfile.write(b"#EXTM3U\n")
        logger.debug("generated playlist:\n#EXTM3U")

        for track in station:
            if "nid" in track:
                line = "#EXTINF:%s,%s%s%s\n%s:%s/get_song?id=%s" % (
                    str(int(int(track["durationMillis"]) / 1000))

                    if "durationMillis" in track else -1,
                    "%s - " % track["artist"] if "artist" in track else "",
                    track["title"] if "title" in track else "",
                    " - %s" % track["album"]

                    if config["extended_m3u"] and "album" in track else "",
                    config["host"],
                    config["port"],
                    track["nid"],
                )
                self.wfile.write(("%s\n" % line).encode("utf-8"))
                logger.debug(line)

    def _get_new_station(self, id, type, numTracks, transient, name):
        stationId = api.create_station(
            name=name,
            track_id=id if type == "song" else None,
            artist_id=id if type == "artist" else None,
            album_id=id if type == "album" else None,
        )  # by genre: TO DO

        if transient != "no":
            transientStationIds.append(stationId)
        station = self._robust_retry(lambda: api.get_station_tracks(
            station_id=stationId, num_tracks=numTracks))

        if transient != "no":
            self._robust_retry(lambda: api.delete_stations(stationId))
            transientStationIds.remove(stationId)
        logger.info(
            "Getting %s tracks from a new %s station based on %s id '%s'" %
            (numTracks, "transient" if transient != "no" else "persistent",
             type, id))
        logger.debug(pprint.pformat(station))
        self.wfile.write(b"#EXTM3U\n")
        logger.debug("generated playlist:\n#EXTM3U")

        for track in station:
            if "nid" in track:
                line = "#EXTINF:%s,%s%s%s\n%s:%s/get_song?id=%s" % (
                    str(int(int(track["durationMillis"]) / 1000))

                    if "durationMillis" in track else -1,
                    "%s - " % track["artist"] if "artist" in track else "",
                    track["title"] if "title" in track else "",
                    " - %s" % track["album"]

                    if config["extended_m3u"] and "album" in track else "",
                    config["host"],
                    config["port"],
                    track["nid"],
                )
                self.wfile.write(("%s\n" % line).encode("utf-8"))
                logger.debug(line)

    def _get_playlist(self, id, shuffle=False):
        logger.info("Getting tracks from playlist with id '%s'", id)

        # necessary to get track information on uploaded songs
        wholeCollection = self._robust_retry(lambda: api.get_all_songs())

        targetPlaylist = None
        self.wfile.write(b"#EXTM3U\n")
        logger.debug("generated playlist:\n#EXTM3U")

        if id[0] == "A" and id[1] == "M":
            targetPlaylist = self._robust_retry(
                lambda: api.get_shared_playlist_contents(id))
            logger.debug(pprint.pformat(targetPlaylist))
        else:
            # we have to download the content of all the playlists (actual API
            # limitation)
            playlistsWithContents = self._robust_retry(
                lambda: api.get_all_user_playlist_contents())
            logger.debug(pprint.pformat(playlistsWithContents))

            for playlist in playlistsWithContents:
                if "id" in playlist and playlist["id"] == id:
                    targetPlaylist = playlist["tracks"]

        if targetPlaylist is not None:
            if shuffle:
                logger.info("Shuffling the playlist")
                random.shuffle(targetPlaylist)

            for track in targetPlaylist:
                if "trackId" in track:
                    foundTrack = None

                    if "track" in track:
                        foundTrack = track["track"]
                    else:
                        for song in wholeCollection:
                            if song["id"] == track["trackId"]:
                                foundTrack = song

                                break

                    if foundTrack:
                        line = "#EXTINF:%s,%s%s%s\n%s:%s/get_song?id=%s" % (
                            str(int(int(track["durationMillis"]) / 1000))

                            if "durationMillis" in foundTrack else -1,
                            "%s - " % foundTrack["artist"]

                            if "artist" in foundTrack else "",
                            foundTrack["title"]

                            if "title" in foundTrack else "",
                            " - %s" % foundTrack["album"]

                            if config["extended_m3u"] and "album" in foundTrack
                            else "",
                            config["host"],
                            config["port"],
                            track["trackId"],
                        )
                        self.wfile.write(("%s\n" % line).encode("utf-8"))
                        logger.debug(line)
                    else:
                        logger.warning(
                            "no information available in collection of track with id '%s'!",
                            track["trackId"],
                        )
        else:
            logger.warning("Playlist not found!")

    def _get_album(self, id):
        album = self._robust_retry(lambda: api.get_album_info(
            album_id=id, include_tracks=True))
        logger.info(
            "Getting the tracks of the album with id '%s': %s - %s",
            id,
            album["name"],
            album["artist"],
        )
        logger.debug(pprint.pformat(album))
        self.wfile.write(b"#EXTM3U\n")
        logger.debug("generated playlist:\n#EXTM3U")

        if "tracks" in album:
            for track in album["tracks"]:
                if "nid" in track:
                    line = "#EXTINF:%s,%s%s%s\n%s:%s/get_song?id=%s" % (
                        str(int(int(track["durationMillis"]) / 1000))

                        if "durationMillis" in track else -1,
                        "%s - " % track["artist"] if "artist" in track else "",
                        track["title"] if "title" in track else "",
                        " - %s" % track["album"]

                        if config["extended_m3u"] and "album" in track else "",
                        config["host"],
                        config["port"],
                        track["nid"],
                    )
                    self.wfile.write(("%s\n" % line).encode("utf-8"))
                    logger.debug(line)

    def _get_top_tracks_artist(self, id, numTracks):
        artist = self._robust_retry(lambda: api.get_artist_info(
            artist_id=id,
            include_albums=False,
            max_top_tracks=numTracks,
            max_rel_artist=0,
        ))
        logger.info(
            "Getting %s top tracks of the artist with id '%s': %s",
            numTracks,
            id,
            artist["name"],
        )
        logger.debug(pprint.pformat(artist))
        self.wfile.write(b"#EXTM3U\n")
        logger.debug("generated playlist:\n#EXTM3U")

        if "topTracks" in artist:
            for track in artist["topTracks"]:
                if "nid" in track:
                    line = "#EXTINF:%s,%s%s%s\n%s:%s/get_song?id=%s" % (
                        str(int(int(track["durationMillis"]) / 1000))

                        if "durationMillis" in track else -1,
                        "%s - " % track["artist"] if "artist" in track else "",
                        track["title"] if "title" in track else "",
                        " - %s" % track["album"]

                        if config["extended_m3u"] and "album" in track else "",
                        config["host"],
                        config["port"],
                        track["nid"],
                    )
                    self.wfile.write(("%s\n" % line).encode("utf-8"))
                    logger.debug(line)

    def _get_discography_artist(self, id, format, separator, onlyUrl):
        artist = self._robust_retry(lambda: api.get_artist_info(
            artist_id=id,
            include_albums=True,
            max_top_tracks=0,
            max_rel_artist=0))
        logger.info(
            "Getting all albums of the artist with id '%s' (%s) as a %s list...",
            id,
            artist["name"],
            "plain-text" if format == "text" else "M3U",
        )
        logger.debug(pprint.pformat(artist))

        if format.lower().strip() != "text":
            self.wfile.write(b"#EXTM3U\n")
        logger.debug("generated list:" if format.lower().strip() ==
                     "text" else "generated list:\n#EXTM3U")

        if "albums" in artist:
            for album in artist["albums"]:
                if "albumId" in album:
                    if format.lower().strip() == "text":
                        line = "%s%s:%s/get_album?id=%s" % (
                            "%s%s%s%s" % (album["name"], separator,
                                          album["year"], separator) if
                            ("name" in album and "year" in album
                             and onlyUrl.lower().strip() != "yes") else "",
                            config["host"],
                            config["port"],
                            album["albumId"],
                        )
                    else:
                        line = "#EXTINF:-1,%s [%s]\n%s:%s/get_album?id=%s" % (
                            album["name"] if "name" in album else "",
                            album["year"] if "year" in album else "",
                            config["host"],
                            config["port"],
                            album["albumId"],
                        )
                    self.wfile.write(("%s\n" % line).encode("utf-8"))
                    logger.debug(line)

    def _get_matches(self, matches, numTracks):
        self.wfile.write(b"#EXTM3U\n")
        logger.debug("generated playlist:\n#EXTM3U")

        for song in matches:
            track = song["track"]

            if "storeId" in track:
                line = "#EXTINF:%s,%s%s%s\n%s:%s/get_song?id=%s" % (
                    str(int(int(track["durationMillis"]) / 1000))

                    if "durationMillis" in track else -1,
                    "%s - " % track["artist"] if "artist" in track else "",
                    track["title"] if "title" in track else "",
                    " - %s" % track["album"]

                    if config["extended_m3u"] and "album" in track else "",
                    config["host"],
                    config["port"],
                    track["storeId"],
                )
                self.wfile.write(("%s\n" % line).encode("utf-8"))
                logger.debug(line)

    def _browser(self,artist = "All Artists",album="All Albums"):
        artists = ["All Artists"]
        for song in self.server.allSongsCache:
            if song['artist'] not in artists:
                if song['artist'] == "" and "unknown" not in artists:
                    artists.append("unknown")
                else:
                    artists.append(song['artist'])

        albums = ["All Albums"]
        for song in self.server.allSongsCache:
            if (artist == "All Artists") or (song['artist'].lower() == artist.lower()):
                if song['album'] not in albums:
                    if song['album'] == "" and "unknown" not in albums:
                        albums.append("unknown")
                    else:
                        albums.append(song['album'])

        template = open('/data/gui_template.html', 'r').read()
        html=Template(template).render(host=config['host'])
        self.wfile.write(html.encode("utf-8"))
    

    def _get_tracks_json(self,artist,album):
        tracks = []
        for song in self.server.allSongsCache:
            if artist == "All Artists" or song['artist'].lower() == artist.lower():
                if album == "All Albums" or song['album'].lower() == album.lower():
                    tracks.append(song["id"] if "id" in song else song["nid"])
        self.wfile.write(json.dumps(tracks).encode("utf-8"))

    def _get_queue_json(self):
        queue = []
        for track in self.server.tracks:            
            song = self._get_track_info(track_id=track)
            if song:
                queue.append("{0} - {1} - {2}. {3}".format(
                    song['artist']      if 'artist'      in song and song['artist'] else "unknown",
                    song['album']       if 'album'       in song else "unknown",
                    song['trackNumber'] if 'trackNumber' in song else "unknown",
                    song['title']       if 'title'       in song else "unknown"
                ))
        self.wfile.write(json.dumps(queue).encode("utf-8"))

    def _append_to_queue(self,artist="",album="",station="",playlist=""):
        tracks = []
        if artist or album:
            logger.info("add songs to queue:{} - {}".format(artist,album))
            songs = self.server.allSongsCache
            songs.sort(key = lambda i: (i["artist"],i["album"],i["trackNumber"]))
            for song in songs:
                if artist == "All Artists" or song['artist'].lower() == artist.lower():
                    if album == "All Albums" or song['album'].lower() == album.lower():
                        tracks.append(song["id"] if "id" in song else song["nid"])            
        if station:
            logger.info("add station to queue:{}".format(station))
            station_tracks = self._robust_retry(lambda: api.get_station_tracks(station_id=station, num_tracks=9999))
            for song in station_tracks:
                logger.info("add song to queue:{}".format(song['title']))
                tracks.append(song["id"] if "id" in song else song["nid"])
 
        if playlist:
            logger.info("add playlist to queue:{}".format(playlist))
            playlist_tracks = self._get_playlist_tracks(playlist_id=playlist)
            logger.info("playlist_tracks :{}".format(playlist_tracks))
            for song in playlist_tracks:
                logger.info("add song to queue:{}".format(song['trackId']))
                tracks.append(song["trackId"])

        self.server.tracks += tracks
        with open('/data/queue.json', 'w') as outfile:
            json.dump(self.server.tracks, outfile)
        self.wfile.write(json.dumps({'result':'ok','message':'{0} tracks added to queue, total {1}!'.format(len(tracks),len(self.server.tracks))}).encode("utf-8"))

    def _clear_queue(self):
        with open('/data/queue.json', 'w') as outfile:
            json.dump('', outfile)
        self.server.tracks = []
        with open('/data/track_index.json', 'w') as outfile:
            json.dump('0', outfile)
        self.server.track_index = 0
        self.wfile.write(json.dumps({'result':'ok','message':'Queue cleared!'}).encode("utf-8"))

    def _shuffle_queue(self):
        random.shuffle(self.server.tracks)
        with open('/data/queue.json', 'w') as outfile:
            json.dump(self.server.tracks, outfile)
        self.wfile.write(json.dumps({'result':'ok','message':'Queue reordered!'}).encode("utf-8"))

    def _previous_track(self):
        if not hasattr(self.server,'track_index'):
            self.server.track_index = 0
        elif self.server.track_index > 0:
            self.server.track_index -= 1
        elif self.server.track_index == 0:
            self.server.track_index = len(self.server.tracks) - 1
        else:
            self.server.track_index == 0
        with open('/data/track_index.json', 'w') as outfile:
            json.dump(self.server.track_index, outfile)
        logger.info("current track_index: %s",self.server.track_index)
        self._get_track_json(self.server.tracks[self.server.track_index])

    def _next_track(self):
        if not hasattr(self.server,'track_index'):
            self.server.track_index = 0
        elif self.server.track_index < (len(self.server.tracks) -1):
            self.server.track_index += 1 
        else:
            self.server.track_index = 0
        with open('/data/track_index.json', 'w') as outfile:
            json.dump(self.server.track_index, outfile)
        logger.info("current track_index: %s",self.server.track_index)
        self._get_track_json(self.server.tracks[self.server.track_index])

    def _current_track(self):
        logger.info("current track_index: %s",self.server.track_index)
        if not hasattr(self.server,'track_index'):
            return
        if len(self.server.tracks) == 0:
            return
        self._get_track_json(track_id=self.server.tracks[self.server.track_index])

    def _get_track_info(self,track_id):
        if track_id == None:
            return
        if track_id.startswith('T'):
            return api.get_track_info(track_id)
            
        for song in self.server.allSongsCache:
            if "id" in song:
                if song['id'] == track_id:
                    return song
            else:            
                if song['nid'] == track_id:
                    return song

    def _get_track_json(self,track_id):
        if track_id == None:
            return
        self.wfile.write(json.dumps(self._get_track_info(track_id)).encode("utf-8"))

    def _get_playlists_json(self):
        playlists = []
        _all_playlists = self._robust_retry(lambda: api.get_all_playlists())
        self.wfile.write(json.dumps(_all_playlists).encode("utf-8"))

    def _get_playlist_tracks(self,playlist_id):
        if not hasattr(self.server, "allPlaylistsCache"):
        	self._fetch_playlist_cache()
        for playlist in self.server.allPlaylistsCache:
            if playlist["id"] == playlist_id:
                return playlist["tracks"]
        
    def _get_stations_json(self):
        stations = []
        _all_stations = self._robust_retry(lambda: api.get_all_stations())
        self.wfile.write(json.dumps(_all_stations).encode("utf-8"))

    def _get_station_json(self,name,numTracks=999):
        tracks = []
        _all_stations = self._robust_retry(lambda: api.get_all_stations())
        for station in _all_stations:
            if station["name"] == name:
                return self._robust_retry(lambda: api.get_station_tracks(station_id=station["id"], num_tracks=numTracks))

    def _get_collection_json(self):
        if not hasattr(self.server, "allSongsCache"):
        	self._fetch_songs_list_cache()
        self.wfile.write(json.dumps(self.server.allSongsCache).encode("utf-8"))

    def _get_collection_artists_json(self):
        if not hasattr(self.server, "allSongsCache"):
        	self._fetch_songs_list_cache()
        artists = []
        for song in self.server.allSongsCache:
            if song['artist'] not in artists:
                if song['artist'] == "" and "unknown" not in artists:
                    artists.append("unknown")
                else:
                    artists.append(song['artist'])
        self.wfile.write(json.dumps(artists).encode("utf-8"))

    def _get_collection_albums_json(self,artist):
        albums = []
        for song in self.server.allSongsCache:
            if (artist == "All Artists") or (song['artist'].lower() == artist.lower()):
                if song['album'] not in albums:
                    if song['album'] == "" and "unknown" not in albums:
                        albums.append("unknown")
                    else:
                        albums.append(song['album'])
        self.wfile.write(json.dumps(albums).encode("utf-8"))


    def _get_collection(self, ratingthreshold=0, shuffle=False):
        songs = self._robust_retry(lambda: api.get_all_songs())
        songs.sort(key = lambda i: (i["artist"],i["album"],i["trackNumber"]))
        if len(songs) == 0:
            logger.warning("No songs in your collection!?!")

            return

        if int(ratingthreshold) > 0:
            logger.info("Filtering out songs with rating lower than %s",
                        ratingthreshold)

            for song in songs:
                songrating = song.get("rating")

                if songrating is not None:
                    if int(songrating) < int(ratingthreshold):
                        songs.remove(song)

        if shuffle:
            logger.info("Shuffling the collection")
            random.shuffle(songs)

        logger.info("Getting your collection: %s tracks", len(songs))
        logger.debug(pprint.pformat(songs))
        self.wfile.write(b"#EXTM3U\n")
        logger.debug("generated playlist:\n#EXTM3U")

        for track in songs:
            if "id" in track or "nid" in track:
                line = "#EXTINF:%s,%s%s%s\n%s:%s/get_song?id=%s" % (
                    str(int(int(track["durationMillis"]) / 1000))

                    if "durationMillis" in track else -1,
                    "%s - " % track["artist"] if "artist" in track else "",
                    track["title"] if "title" in track else "",
                    " - %s" % track["album"]

                    if config["extended_m3u"] and "album" in track else "",
                    config["host"],
                    config["port"],
                    track["id"] if "id" in track else track["nid"]
                )
                self.wfile.write(("%s\n" % line).encode("utf-8"))
                logger.debug(line)

    def _get_promoted(self, shuffle=False):
        songs = self._robust_retry(lambda: api.get_promoted_songs())

        if len(songs) == 0:
            logger.warning("No promoted tracks!?!")

            return

        if shuffle:
            logger.info("Shuffling promoted tracks")
            random.shuffle(songs)

        logger.info("Getting promoted tracks: %s tracks", len(songs))
        logger.debug(pprint.pformat(songs))
        self.wfile.write(b"#EXTM3U\n")
        logger.debug("generated playlist:\n#EXTM3U")

        for track in songs:
            if "storeId" in track:
                line = "#EXTINF:%s,%s%s%s\n%s:%s/get_song?id=%s" % (
                    str(int(int(track["durationMillis"]) / 1000))

                    if "durationMillis" in track else -1,
                    "%s - " % track["artist"] if "artist" in track else "",
                    track["title"] if "title" in track else "",
                    " - %s" % track["album"]

                    if config["extended_m3u"] and "album" in track else "",
                    config["host"],
                    config["port"],
                    track["storeId"],
                )
                self.wfile.write(("%s\n" % line).encode("utf-8"))
                logger.debug(line)

    def _search(self, type, query_title, query_artist, exact,
                max_results=None):

        if type is None or type not in ["artist", "song", "album", "matches"]:
            logger.warning(
                "The type of search has to be specified: artist, song, album or matches!"
            )

            return
        logger.info("Searching for %s with query: %s %s", type, query_artist,
                    query_title)
        match = None

        if type == "artist":
            results = self._robust_retry(lambda: api.search(query_artist))
            logger.debug(pprint.pformat(results))

            if (exact != "yes" and "artist_hits" in results
                    and len(results["artist_hits"]) > 0):
                logger.debug(
                    "I'm feeling lucky: lets select the first artist in list!")
                match = results["artist_hits"][0]
            else:
                if "artist_hits" in results:
                    for artist in results["artist_hits"]:
                        if ("name" in artist["artist"]
                                and artist["artist"]["name"].lower().strip() ==
                                query_artist.lower().strip()):
                            logger.debug(
                                "Found exact matching artist in list!")
                            match = artist

                            break

            if match and "artist" in match and "artistId" in match["artist"]:
                logger.info(
                    "Selected artist: %s (%s)",
                    match["artist"]["name"],
                    match["artist"]["artistId"],
                )
                logger.debug(pprint.pformat(match))

                return match["artist"]["artistId"]
            else:
                logger.warning("No matching found.")
        elif type == "song":
            results = self._robust_retry(lambda: api.search("%s %s" % (
                query_artist, query_title)))
            logger.debug(pprint.pformat(results))

            if (exact != "yes" and "song_hits" in results
                    and len(results["song_hits"]) > 0):
                logger.debug("I'm feeling lucky: lets select the first song!")
                match = results["song_hits"][0]
            else:
                if "song_hits" in results:
                    for song in results["song_hits"]:
                        if ("title" in song["track"]
                                and song["track"]["title"].lower().strip() ==
                                query_title.lower().strip()
                                and "artist" in song["track"]
                                and song["track"]["artist"].lower().strip() ==
                                query_artist.lower().strip()):
                            logger.debug("Found exact matching song!")
                            match = song

                            break

            if match and "track" in match and "storeId" in match["track"]:
                logger.info(
                    "Selected song: %s - %s (%s)",
                    match["track"]["artist"],
                    match["track"]["title"],
                    match["track"]["storeId"],
                )
                logger.debug(pprint.pformat(match))

                return match["track"]["storeId"]
            else:
                logger.warning("No matching found.")
        elif type == "matches":
            results = self._robust_retry(lambda: api.search(
                "%s %s" % (query_artist, query_title), max_results))
            logger.debug(pprint.pformat(results))
            match = results["song_hits"]

            if match:
                return match
            else:
                logger.warning("No matching found.")
        elif type == "album":
            results = self._robust_retry(lambda: api.search("%s %s" % (
                query_artist, query_title)))
            logger.debug(pprint.pformat(results))

            if (exact != "yes" and "album_hits" in results
                    and len(results["album_hits"]) > 0):
                logger.debug(
                    "I'm feeling lucky: lets select the first album in list!")
                match = results["album_hits"][0]
            else:
                if "album_hits" in results:
                    for album in results["album_hits"]:
                        if ("name" in album["album"]
                                and album["album"]["name"].lower().strip() ==
                                query_title.lower().strip()
                                and "artist" in album["album"]
                                and album["album"]["artist"].lower().strip() ==
                                query_artist.lower().strip()):
                            logger.debug("Found exact matching album in list!")
                            match = album

                            break

            if match and "album" in match and "albumId" in match["album"]:
                logger.info(
                    "Selected album: %s - %s (%s)",
                    match["album"]["artist"],
                    match["album"]["name"],
                    match["album"]["albumId"],
                )
                logger.debug(pprint.pformat(match))

                return match["album"]["albumId"]
            else:
                logger.warning("No matching found.")
        else:
            return

    def _rate_song(self, id, rating=0):
        if config["disable_all_access"]:
            info = None
            # the same not so nice trick as above
            allSongs = self._robust_retry(lambda: api.get_all_songs())

            for song in allSongs:
                if "nid" in song and song["nid"] == id:
                    info = song.copy()

                    break
            allSongs = None
        else:
            if id[0] == "T":
                info = self._robust_retry(lambda: api.get_track_info(
                    store_track_id=id))
            else:
                logger.error(
                    "Unsupported id '%s': report info to reproduce this to the author",
                    id,
                )

        if info is None:
            logger.warning("Song with id '%s' not found.", id)
        else:
            logger.info(
                "Reporting rating=%s on song with id '%s': %s - %s",
                rating,
                id,
                info["artist"],
                info["title"],
            )
            logger.debug(pprint.pformat(info))
            info["rating"] = rating
            self._robust_retry(lambda: api.rate_songs(info, rating))

    @gmusicapi.utils.utils.retry(
        retry_exception=requests.exceptions.ConnectionError)
    def _robust_retry(self, func):
        return func()

    def handle_one_request(self):
        try:
            BaseHTTPRequestHandler.handle_one_request(self)
        except CallFailure as e:
            if "401 Client Error: Unauthorized" in str(e):
                logger.warning(
                    "Server denied authorization, trying to reconnect...")
                api.logout()
                device_id = gmusicapi.Mobileclient.FROM_MAC_ADDRESS
                api.oauth_login(device_id)

                if api.is_authenticated():
                    self.handle_one_request()
                else:
                    logger.error(
                        "Sorry, could not reconnect, those credentials weren't accepted."
                    )
                    sys.exit(1)
            else:
                raise
        except socket.error as e:
            if e == errno.ECONNRESET:
                logger.warning("Detected connection reset.")
            elif e == errno.EPIPE:
                logger.warning("Detected remote peer disconnected.")
            elif e == 10053:
                logger.warning(
                    "An established connection was aborted by the software in your host machine."
                )
            else:
                raise

    def finish(self, *args, **kw):
        # fix from http://stackoverflow.com/a/14355079/1834797
        try:
            if not self.wfile.closed:
                self.wfile.flush()
                self.wfile.close()
        except socket.error:
            pass
        self.rfile.close()


def signalHandler(signal, frame):
    logger.info("Shutting down the proxy...")

    if server:
        server.socket.close()

    if len(transientStationIds) and api:
        api.delete_stations(transientStationIds)

    if api:
        api.logout()

    if opener:
        opener.close()
    sys.exit()


def getOptions():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-o", "--oauth",
        default=False,
        action='store_true',
        help="cache OAuth2 credentials (required for All Access)")
    parser.add_argument(
        "-H",
        "--host",
        help="host in the generated URLs [default: autodetected local ip address]",
    )
    parser.add_argument(
        "-b",
        "--bind-address",
        help="ip address to bind to [default: 0.0.0.0=all]")
    parser.add_argument(
        "-P",
        "--port",
        type=int,
        help="default TCP port to use [default: 9999]")
    parser.add_argument(
        "-a",
        "--disable-all-access",
        default=False,
        action="store_true",
        help="disable All Access functionalities",
    )
    parser.add_argument(
        "-D",
        "--debug",
        default=False,
        action="store_true",
        help="enable debug messages",
    )
    parser.add_argument("-l", "--log", help="log file")
    parser.add_argument(
        "-f",
        "--daemon",
        default=False,
        action="store_true",
        help="daemonize the program",
    )
    parser.add_argument(
        "-x",
        "--extended-m3u",
        default=False,
        action="store_true",
        help="enable non-standard extended m3u headers",
    )
    parser.add_argument(
        "-s",
        "--shoutcast-metadata",
        default=False,
        action="store_true",
        help="enable Shoutcast metadata protocol support (disabling IDv3 tags)",
    )
    parser.add_argument(
        "-C",
        "--disable-playcount-increment",
        default=False,
        action="store_true",
        help="disable the automatic increment of playcounts upon song fetch",
    )

    config = ConfigParser()
    args = parser.parse_args()
    configValues = dict(config.items())

    # adjust some names in order to make work configparser with argparse
    for key in list(configValues.keys()):
        if "-" in key:
            configValues[key.replace("-", "_")] = configValues.pop(key)

    if "bind_address" in configValues and "host" not in configValues:
        configValues["host"] = configValues["bind_address"]

    # some defaults
    if "bind_address" not in configValues:
        configValues["bind_address"] = "0.0.0.0"

    if "host" not in configValues:
        configValues["host"] = "**auto**"

    if "port" not in configValues:
        configValues["port"] = "9999"

    parser.set_defaults(**configValues)
    args = parser.parse_args()
    config = vars(args)

    return config


def initOauth2(device_id=gmusicapi.Mobileclient.FROM_MAC_ADDRESS):
    api = gmusicapi.Mobileclient()
    api.perform_oauth(storage_filepath=u'/data/mobileclient.cred',open_browser=False)
    api.oauth_login(device_id)


def loginGM(device_id=gmusicapi.Mobileclient.FROM_MAC_ADDRESS,oauth_credentials=u'/data/mobileclient.cred'):
    api = gmusicapi.Mobileclient()
    if config['debug']:
        api.logger = logger
    api.oauth_login(device_id,oauth_credentials)
    if not api.is_authenticated():
        logger.error('Sorry, those credentials weren\'t accepted.')
        sys.exit(1)
    return api



if __name__ == "__main__":
    downloadBlockSize = 16 * 1024
    cachePrefillSize = 60 * 320 / 8 * 1024  # 60 seconds at 320 kbit/s
    maxCacheSize = 180 * 320 / 8 * 1024  # 180 seconds
    defaultNumberTracksStation = 50
    defaultNumberTopTracks = 20
    programDescription = "Google Play Music Proxy"
    programName = "gmusicproxy"
    programMainAuthor = "Mario Di Raimondo"
    programVersion = "1.0.11"
    transientStationName = "%s station " % programDescription
    transientStationIds = []
    config = dict()

    # remove previous root logging handler
    logger = logging.getLogger()
    list(map(logger.removeHandler, logger.handlers[:]))

    # initial setup of my logger
    logger = logging.getLogger(programName)
    logger.setLevel(logging.INFO)
    consoleHandler = logging.StreamHandler(sys.stdout)
    consoleHandler.setFormatter(logging.Formatter("%(message)s"))
    logger.addHandler(consoleHandler)

    config = getOptions()

    # complete setup of the logger
    fileHandler = None

    if config["oauth"]:
        initOauth2(gmusicapi.Mobileclient.FROM_MAC_ADDRESS)
        print("Done.")
        sys.exit(0)

    if config["log"]:
        fileHandler = logging.FileHandler(config["log"], encoding="utf-8")
        logger.addHandler(fileHandler)

    if config["debug"]:
        logger.setLevel(logging.DEBUG)

        if fileHandler:
            fileHandler.setFormatter(
                logging.Formatter(
                    "[%(levelname)s] (%(module)s:%(lineno)s): %(message)s"))

    logger.info("%s %s (Â© %s)\n", programDescription, programVersion,
                programMainAuthor)

    # preliminary setup for the daemonaization
    if config["daemon"]:
        if os.name == "nt":
            logger.error("Daemon-mode is not supported under Windows!")
            sys.exit(1)

        if "daemon" not in globals():
            logger.error("Python 'daemon' module is not installed!")
            sys.exit(1)
        contextDaemon = daemon.DaemonContext(files_preserve=[])
        # python-daemon>=2.1 has initgroups=True by default but it requires
        # root privileges. older versions don't support initgroups as
        # constructor parameter so we set it manually instead
        contextDaemon.initgroups = False

        if fileHandler:
            contextDaemon.files_preserve.append(fileHandler.stream)
        consoleHandler.setLevel(logging.ERROR)

    safeConfig = config.copy()
    logger.debug("configuration used:\n%s\n", pprint.pformat(safeConfig))

    api = loginGM()


    opener = build_opener()
    opener.addheaders = [("User-agent",
                          "%s %s" % (programDescription, programVersion))]

    signal.signal(signal.SIGINT, signalHandler)

    server = MultiThreadedHTTPServer((config["bind_address"], config["port"]),
                                     GetHandler)

    logger.info("Pre-fetching list of songs in collection")
    server.lock = threading.Lock()
    server.allSongsCache = api.get_all_songs()
    server.allPlaylistsCache = api.get_all_user_playlist_contents()
    
    if os.path.exists('/data/queue.json'):
        with open('/data/queue.json',"r") as inputfile:
            server.tracks = json.load(inputfile)
    else:
        with open('/data/queue.json', 'w') as outfile:
            json.dump('', outfile)
        server.tracks = []

    if os.path.exists('/data/track_index.json'):
        with open('/data/track_index.json',"r") as inputfile:
            server.track_index = int(json.load(inputfile))
            if server.track_index < 0 or server.track_index > (len(server.tracks) -1):
                server.track_index = 0
    else:
        with open('/data/track_index.json',"w") as outfile:
            json.dump('0',outfile)
        server.track_index = 0

    logger.info("Listening on %s:%s...", config["bind_address"],
                config["port"])

    if config["daemon"]:
        contextDaemon.files_preserve.append(server.fileno())
        with contextDaemon:
            server.serve_forever()
    else:
        server.serve_forever()
